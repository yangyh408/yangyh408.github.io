<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F03%2F21%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python调用飞书API接口]]></title>
    <url>%2F2020%2F03%2F21%2FPython%E8%B0%83%E7%94%A8%E9%A3%9E%E4%B9%A6API%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[写在最前 飞书作为一款高效远程办公软件，在疫情期间凭借着人性化的UI交互以及稳定的远程联络能力深得各大企业的偏好。但在创建团队之初，难免遇到需要批量导入数据或者批量处理员工信息的情况，飞书为此提供了各种API接口以便集中处理这些情况，此文的目的也是为了让各位团队管理者能自如使用这些API接口。 Python调用API接口 在了解飞书API接口前，我们先熟悉如何用python发送和接受请求，这里我是用的是requests模块。 POST请求方式具体请求地址、Header、Body会在接口声明中提及，执行request.post()后会接收返回Body。12345678910# 请求地址url = "https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/"# 请求Header（字典形式储存）header = &#123;"content-type":"application/json", "Authorization":"Bearer " + str(tat)&#125;# 请求Body（字典形式储存）post_data = &#123;"app_id":"xxx", "app_secret":"xxx"&#125;# 发送POST请求r = requests.post(url, data=post_data, headers=header) GET请求方式与POST请求方式大致相同，具体参数内容参见接口声明。1234567# 请求Header（字典形式储存）header = &#123;"content-type":"application/json", "Authorization":"Bearer " + str(tat)&#125;# 请求地址url = "https://open.feishu.cn/open-apis/contact/v1/tenant/custom_attr/get"# 发送GET请求r = requests.get(url, headers = header) 解析json为便于对返回Body进行处理，我们通常将返回信息以json形式展示，方法如下：1r.json() 飞书API接口调用准备 这一部分建议大家查阅飞书API官方文档，以下两项为补充文档中未详细提及的部分 获取授权凭证在使用API之前我们要先获得三种授权凭证，分别是： app_access_token ：访问App资源相关接口。 tenant_access_token ：访问企业资源相关接口。 user_access_token ：访问用户资源相关接口。 我们这里只介绍在企业管理中最常用到tenant_access_token的获取方式： 管理后台创建企业自建应用 记录应用凭证内AppID和AppSecret备用 从左侧三种应用功能任选一种 根据后续操作需要选择所需权限，具体权限内容参见这里 发布应用（应用于所有部门） 利用Request获取 app_access_token（企业自建应用） 明确API调用顺序在这一部分我们以批量导入联系人为例（文末有python代码）： 由于诸如部门id以及通讯录字段id等信息无法直接获得，我们在导入联系人前要先获得这些id信息 获取tenant_access_token 获取企业自定义用户属性配置 获取通讯录授权范围（所有部门id列表） 建立部门id与真实部门的键值对应关系 批量新增用户 pandas模块读取excel数据 因为在批量处理用户信息时我们所需要的基本都是从已有excel中读取相关信息，所以我们在这里只对pandas的读取功能做简要介绍。 import pandas as pd 导入pandas模块 data = pd.read_csv( file, sep, encoding, nrows, skiprows) data = pd.read_excel( file, sep, encoding, nrows, skiprows) file为导入文件目录，sep为数据分隔符，nrows为读取前n行，skiprows为跳过某几行 pd.DataFrame() 创建一个DataFrame对象 data.head(3)/data.tail(3) 读取数据头/末3行 data.iloc[] 提供基于整数的索引方式,索引序数而非标签 data.to_numpy() 将pandas数组转化为np数组处理（对，有什么pandas数组不会的转成np数组操作岂不美汁汁） 实例：飞书批量导入联系人 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import jsonimport requestsimport pandas as pd# 获取tenant_access_tokenurl = "https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal/"post_data = &#123;"app_id":"xxx", "app_secret":"xxx"&#125;r = requests.post(url, data=post_data)tat = r.json()["tenant_access_token"]# 获取通讯录自定义字段idheader = &#123;"content-type":"application/json", "Authorization":"Bearer " + str(tat)&#125;url = "https://open.feishu.cn/open-apis/contact/v1/tenant/custom_attr/get"r = requests.get(url, headers = header)qq_id = list(r.json()["data"]["custom_attrs"].keys())[0]sn_id = list(r.json()["data"]["custom_attrs"].keys())[1]# 获取部门iddepartment = &#123;&#125;sex = &#123;"男":"1", "女":"2"&#125;url = "https://open.feishu.cn/open-apis/contact/v1/scope/get"r = requests.get(url, headers = header)ls = r.json()["data"]["authed_departments"]for i in range(len(ls)): url = "https://open.feishu.cn/open-apis/contact/v1/department/info/get?department_id=" + str(ls[i]) r = requests.get(url, headers = header) name = r.json()["data"]["department_info"]["name"] department[name] = ls[i]# 批量导入联系人信息url = "https://open.feishu.cn/open-apis/contact/v1/user/add"data = pd.read_excel('class_data.xlsx')data = data.iloc[2:, :]data = data.to_numpy()for i in range(len(data)): user_data = &#123; "name":data[i][0], "department_ids":[department[data[i][4][:7]]],# "email":"zhangsan@gmail.com", "mobile":"+86"+str(data[i][5]), "mobile_visible":"true", "city":data[i][7], "country": "CN", "gender":sex[data[i][1]], "employee_type":1, "employee_id":"id_" + str(data[i][3]), "employee_no":str(data[i][3]), "need_send_notification":"true", "custom_attrs":&#123; qq_id: &#123; "value": str(data[i][6]) &#125;, sn_id: &#123; "value": str(data[i][3]) &#125; &#125; &#125; data_to_send = json.dumps(user_data).encode("utf-8") r = requests.post(url, data = data_to_send, headers = header) print(r.json())]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium实现自动健康填报]]></title>
    <url>%2F2020%2F03%2F18%2Fselenium%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%81%A5%E5%BA%B7%E5%A1%AB%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[selenium模拟浏览器操作 在这部分开头我先贴出了自动执行填写健康信息的脚本，对于selenium较为详细的解析和使用指南放在了这一部分的后半段 selenium实战为什么突然想到学习一波selenium的用法呢？一方面是在爬虫学习中听说过有这么一款功能极强的浏览器操作模块，另一方面正赶上疫情爆发大家每天都要填报个人健康情况，对于大多数同学基本都能保持健康，每日填写信息也都大同小异，那为什么不让电脑每天自动帮我们上报呢？这样也能避免错过当天的填报时间。 123456789101112131415161718192021222324252627282930from selenium import webdriverimport timefrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument("--headless")driver = webdriver.Chrome(executable_path="/usr/local/bin/chromedriver",options=chrome_options)driver.implicitly_wait(5)url = "http://xgsys.swjtu.edu.cn/SPCP/Web/UserLogin.aspx"driver.get(url)value = &#123; "StudentId": "这儿写学号", "Name": "这儿写名字", "StuCard": "这儿写身份证号后六位", "codeInput": driver.find_element_by_id('code-box').text&#125;for key in value.keys(): element = driver.find_element_by_id(key) element.send_keys(value[key])driver.find_element_by_id('Button4').click()if len(driver.find_elements_by_class_name('layui-layer-content')) == 0: driver.execute_script('document.documentElement.scrollTop=10000') driver.find_element_by_id('Checkbox1').click() driver.find_element_by_id('Save_Btn').click() time.sleep(2)driver.get_screenshot_as_file("./screenshot.png")print(driver.find_element_by_class_name('layui-layer-padding').text)driver.close() 安装selenium首先和安装其他python模块一样，使用pip来安装selenium库1pip3 install selenium 因为selenium要控制浏览器进行操作，我们还需要下载浏览器的驱动以解析python发送给它的指令，根据浏览器的类型及版本选择不同驱动进行下载 四大主流浏览器下载地址：Chrome、Safari、Edge、Firefox 对于MacOS和Linux用户 (以chrome为例) ： 将下载好的文件放入目录/usr/local/bin或/usr/bin中 1sudo cp 当前chromedriver位置 /usr/local/bin 将驱动赋予执行权限 1sudo chmod +x /usr/local/bin/chromedriver selenium常用函数 不弹出浏览器窗口并执行后续操作 1234from selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument("--headless")driver = webdriver.Chrome(options=chrome_options) webdriver.Chrome(&lt;executable_path&gt;?,&lt;options&gt;?)激活网页驱动器，executable_path用于传入网页驱动程序位置，options用于传入后续不弹出浏览器的个性化设置 &lt;webdriver&gt;.get(url)通过链接访问网站 &lt;webdriver&gt;.find_element_by_id(&#39;key&#39;)通过id检索元素 &lt;webdriver&gt;.find_element_by_class_name(&#39;key&#39;)通过class检索元素，返回第一个符合元素 &lt;webdriver&gt;.find_elements_by_class_name(&#39;key&#39;)通过class检索元素，返回列表（其余选择元素方法中elements作用也相同） &lt;webdriver&gt;.find_element_by_tag_name(&#39;key&#39;)通过tag检索元素，返回第一个符合元素 &lt;webdriver&gt;.implicitly_wait(10)最大等待时间 &lt;webdriver&gt;.page_source返回当前网页HTML内容 &lt;webdriver&gt;.get_screenshot_as_file(&#39;file_path&#39;)将当前网页截图并保存 &lt;driver_element&gt;.click()点击该选中元素 &lt;driver_element&gt;.clear()清除输入框已有的字符串 &lt;driver_element&gt;.send_keys(&#39;input&#39;)在输入框中输入数据 &lt;driver_element&gt;.text 返回元素文本内容 crontab定时执行脚本 crontab常用指令 在编辑任务时可能需要使用Vim修改，这里有关于Vim的教程 编辑当前用户crontab任务 crontab -e 查看当前用户所有crontab 列表 crontab -l 删除当前用户所有crontab 列表 crontab -r crontab命令格式crontab命令由六部分构成: M H D m d command M: 分（0-59）H: 时（0-23）D: 天（1-31）m: 月（1-12）d: 周（0-6），0为星期日command: 操作指令 *: 取值范围内的所有数字/: 代表”每”，如/3表示每3个-: 代表从某个数字到某个数字,: 代表离散的取值(取值的列表) 下面我们举一些常见的例子： * * * * * date&gt;&gt;cron.log 每分钟执行将当前计算机时间输入cron.log * */3 * * * date&gt;&gt;cron.log 每三小时执行 00 12 10-15 * * date&gt;&gt;cron.log 每月10-15号12:00执行 * * * * 6,0 date&gt;&gt;cron.log 每周六日执行 crontab常见问题 解决macos下crontab不执行的问题： 12345678910# 检查launchctl中有没有cron任务：sudo launchctl list | grep cron # 查看启动项配置：locate com.vix.cron# 创建database（如果提示warning的话）：sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist# 查看 /etc/crontab 是否存在ll /etc/crontab# 如果没有则一定要创建 /etc/crontabsudo touch /etc/crontab crontab中python的执行路径为/usr/bin/python3，可以用指令安装模块：/usr/bin/pip3 install selenium --user 使用which python3查看终端内使用的python路径 如果在同一任务中执行多条指令，指令间可以用;隔开 如果需要查看任务报错信息，需要在输出文件后加&gt;2&amp;1 参考资料 莫烦PYTHON-高级爬虫 白月黑羽教Python-自动化和性能测试 crontab 在mac上不执行问题研究 Mac下定时执行python脚本&amp;sh脚本]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DigitalOcean的使用]]></title>
    <url>%2F2019%2F04%2F09%2FDigitalOcean%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[创建Droplets 配置选择 image 选择Ubuntu系统Size 选第一个5$/mon 节点选择联通用户推荐选择SanFrancisco-01 通过ping来检测丢包率和延迟，200ms一下就很优秀 通过speedtest来测单线程连接速率，能否把带宽跑满 查看服务器信息 进入您的邮箱，此时您会收到一封包含服务器详细登陆信息的邮件 登陆服务器 在终端中输入： 1ssh Username @ IP Address 安装最新内核 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 安装脚本加密类型选择:14）chacha20-ietf-poly1305 123wget --no-check-certificate -O shadowsocks-libev-debian.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev-debian.shchmod +x shadowsocks-libev-debian.sh./shadowsocks-libev-debian.sh 2&gt;&amp;1 | tee shadowsocks-libev-debian.log 稍等片刻，完成！ 详细信息可以查看秋水逸冰的博文! 导入Shadowsocks 在服务器设置中输入服务器的地址、节点、加密方法、密码即可 ⚠️注意:将指定网站加入PAC规则中：|| www.example.com ^ 福利鸭 完成在读大学生认证可以在GitHub学生礼包中免费领取$50的DigitalOcean抵用券嗷！]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速傅立叶变换(FFT)]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT%2F</url>
    <content type="text"><![CDATA[例题UOJ#34. 多项式乘法题面 题目描述给你两个多项式，请输出乘起来后的多项式。输入格式第一行两个整数 n 和 m，分别表示两个多项式的次数。第二行 n+1 个整数，分别表示第一个多项式的 0 到 n 次项前的系数。第三行 m+1 个整数，分别表示第一个多项式的 0 到 m 次项前的系数。输出格式一行 n+m+1 个整数，分别表示乘起来后的多项式的 0 到 n+m 次项前的系数。样例input:1 21 21 2 1output:1 4 5 2explanation:$(1+2x)⋅(1+2x+x^2)=1+4x+5x^2+2x^3$限制与约定0≤n , m≤$10^5$ 简要解析 首先这道涉及多项式乘法,求相乘后新多项式的系数,可简记为: C(x)=A(x)*B(x)=\sum_{j=0}^{2*n-2} (\sum_{k=0}^ja_k*b_{k-j})x^j 正常算法的时间复杂度很容易得到,即O($n^2$),显然无法再规定时间内得到正确解,怎么办呢?这里我们介绍一种可在O($nlgn$)复杂度下快速求出该答案的方法,即FFT.希望读者在阅读此文后可自行编写! 多项式多项式的表示 系数表达 系数表达是我们平时最常见的表示多项式的方法,对任意一个多项式$A(x)=\sum{i=0}^{n-1}a_ix^i$,其系数表示为$$A(x)=(a_0,a_1,\dots,a{n-1})系数表达的优势是它很容易求出该多项式在点$x_0$处的值$A(x_0)$,即利用[霍纳法则][2](也称秦九韶算法): A(x0)=a_0+x_0(a_1+x_0(a_2+\dots+x_0(a{n-2}+x0a{n-1})\dots)) $$ 点值表达 所谓点值表达就是将一个次数界为n的多项式用 n个点值对 的集合来表示,即: A(x)=\{ (x_0,y_0),(x_1,y_1),(x_2,y_2)\dots(x_{n-1},y_{n-1}) \} 需要注意的是,一定需要n个点值对来表示,因为只有点值对数等于多项式的次数界时,其插值(由点值表达确定该多项式的系数表达,后边会讲到)才明确,这个结论可以由插值多项式的唯一性证明: \begin{vmatrix}\\ 1 & x_0 & x_0^2 & \cdots & x_0^{n-1}\\ 1 & x_1 & x_1^2 & \cdots & x_1^{n-1}\\ \vdots & \vdots & \vdots & &\vdots\\ 1 & x_{n-1} & x_{n-1}^2 & \cdots & x_{n-1}^{n-1}\\ \end{vmatrix} \begin{vmatrix}\\ a_0\\ a_1\\ a_2\\ \vdots\\ a_{n-1}\\ \end{vmatrix}= \begin{vmatrix}\\ y_0\\ y_1\\ y_2\\ \vdots\\ y_{n-1}\\ \end{vmatrix}先将多项式转化为矩阵乘法的形式,其中第一项为范德蒙德行列式,记为$V(x0,x_1,x_2,\dots,x{n-1})$,其值为 $\prod{0\le j&lt;k\le n-1}(x_k-x_j)$ ,显然当任意两个x值不同时该值不为0,故该矩阵可逆,进而可以求得$a=V(x_0,x_1,x_2,\dots,x{n-1})^{-1}y$ , 故其唯一性得证! 点值表示有什么优势呢?我们可以在O(n)的时间内求出两多项式的乘积!如果我们有一种很快的算法可以将系数表达式转化为点值表达式,那么我们就可以快速计算出两多项式的乘积.为了快速实现两种表达方式的快速转化,我们引入一个概念, 单 位 复 数 根 ! 单位复数根定义满足$w^n=1$的复数$w$,其单位复数根恰好有n个,分别为$e^{2\pi ik/n},k={0,1,2,\dots,n-1}$,由复数的指数形式定义$e^{iu}=cos(u)+isin(u)$可将其转化为 $y_k=cos(2 \pi k/n)+isin(2\pi k/n)$ 基本性质 消去引理W_{dn}^{dk}=(e^{2\pi i/{dn}})^{kn}=(e^{2\pi i/{d}})^{k}=W_n^k(n\ge 0 , k\ge 0 , d>0) 折半引理 若n&gt;0且为偶数,那么n个n次单位复数根的平方的集合就是$n/2$个$n/2$次单位复数根的集合(每个元素出现两次)(W_n^{k+n/2})^2=W_n^{2k+n}=W_n^{2k}\cdot W_n^n=(W_n^k)^2=W_{n/2}^k 求和引理\sum_{j=0}^{n-1}(W_n^k)^j=\frac{(W_n^k)^n-1}{W_n^k-1}=\frac{(W_n^n)^k-1}{W_n^k-1}=0 DFT离散傅里叶变换这个算法的核心是利用了卷积定理a\times b=DFT^{-1}_{2n}(DFT_{2n}(a)\cdot DFT_{2n}(b)) 本文最开始的例题UOJ#34,目标多项式的系数$ck=\sum{k=0}^jak*b{k-j}$,熟悉的人可能都知道这实际上就是a,b的卷积,能用傅里叶变换求解的题目一般都可以被转化成类似这样的卷积的形式,大家一定要对这个式子足够熟悉!!! y_k=A(W_n^k)=\sum_{j=0}^{n-1}a_j\cdot W_n^{kj}=\sum_{j=0}^{n-1}a_j\cdot e^{\frac{2\pi i}{n}jk}该算法的复杂度是O($n^2$)的,有没有适当变换使其结合一些复数根的性质加速此过程?答案是肯定的! FFT快速傅里叶变换递归利用分治的思想将$A(x)=a0+a_1x+a_2x^2+\dots+a{n-1}x^{n-1}$分为下标为奇数和偶数的两部分: A^{[0]}(x)=a_0+a_2x+a_4x^2+\dots+a_{n-2}x^{\frac{n}{2}-1}A^{[1]}(x)=a_1+a_3x+a_5x^2+\dots+a_{n-1}x^{\frac{n}{2}-1}A(x)=A^{[0]}(x^2)+x*A^{[1]}(x^2)这样的话问题就可以转化求在$(W_n^0)^2,(W_n^1)^2,\dots,(W_n^{n-1})^2$上A(x)值,又根据折半引理,只需计算次数界为n/2的值即可,这样一直递归下去,即可在O($nlgn$)复杂度内计算出结果,附上伪代码:123456789101112131415FFT(a): n=a.length() if n==1: return a w_n=e^(pi*i/n)=complex(cos(2*pi/n),sin(2*pi/n)) w=1 a(0)=[a0,a2,...a_n-2] a(1)=[a1,a3,...a_n-1] y(0)=FFT(a(0)) y(1)=FFT(a(1)) for k in range(0,n/2): y_k=y_k(0)+w*y_k(1) //w*y_k(1)为公用子表达式 y_k+n/2=y_k(0)-w*y_k(1) w=w*w_n //w为旋转因子 return y 但递归的常数是很大的,我们是否可以进一步优化常数呢?只要将递归过程改为迭代的过程就好了! 迭代 位逆序置换 观察其下标序列为0,4,2,6,1,5,3,7 对应的二进制数为000,100,010,110,001,101,011,111 若将每个数的二进制位反转,即得到000,001,010,011,100,101,110,111 显然为0~7这8个数的升序排列,这样我们就找到了运算顺序与下标间的对应关系,这个过程就叫做位逆序置换,这样我们只要在计算之前将下标通过位逆序置换的方式更新即可按序自底向上求解,代码很简单: 123456inline int rev(int x,int n) //x为当前处理的待改变的数,n为二进制位的总长度(按上例则n=3)&#123; int x0=0; while(n--) x0=(x0+(x&amp;1))&lt;&lt;1,x&gt;&gt;=1; return x0&gt;&gt;1;&#125; 蝴蝶操作 y_k=A(W_n^k)=y^{[0]}_k+W_n^k\cdot y_k^{[1]}y_{k+\frac{n}{2}}=A(W_n^{k+\frac{n}{2}})=A^{[0]}(W_n^{2k+n})+W_n^{k+\frac{n}{2}}\cdot A^{[1]}(W_n^{2k+n})=A^{[0]}(W_n^{2k})+W_n^{k+\frac{n}{2}}\cdot A^{[1]}(W_n^{2k})=y^{[0]}_k-W_n^k\cdot y_k^{[1]} 因此只要知道出$y^{[0]}k$与$W_n^k\cdot y_k^{1}$的值就可直接算出$y_k$与$y{k+\frac{n}{2}}$的值,只要将上一步中分成的树状结构从下向上计算一遍就能求出答案了,这一操作也被称为蝴 蝶 操 作,伪代码如下: 12345for k in range(0,n/2): t=w*y_k(1) y_k=y_k(0)+t y_k+n/2=y_k(0)-t w=w*w_n 傅里叶逆变换公式以上我们了解到如何将系数表示转换为点值表示,通过点值表示在O(n)复杂度下求出多项式的乘积之后只要再将点值表示转换为系数表示(求插值)即可.前面讲多项式的点值表达时我们提到了一种求插值的过程,$a=V(x0,x_1,x_2,\dots,x{n-1})^{-1}\cdot y$ , 即只要得到范德蒙德行列式的逆矩阵就能求出对应的a. 由于一个矩阵的逆矩阵$A^{-1}=\frac{1}{|A|}A^*$,易推得傅里叶逆变换公式: a_k=\frac{1}{n}\sum_{j=0}^{n-1}y^j\cdot e^{-\frac{2\pi i}{n}jk}除了这种求逆矩阵的方法,我们还可以用拉格朗日公式求插值,但复杂度为O($n^2$),公式如下: A(x)=\sum_{k=0}^{n-1}y_k\frac{ \prod_{j\neq k}(x-x_j) }{ \prod_{j\neq k}(x_j-x_k) }代码UOJ#34代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define pi acos(-1.0)#define maxn 300010//#define DEBUG //DEBUG无视就好using namespace std;int n,m;complex&lt;double&gt; a[maxn],b[maxn];inline int read() //读入优化&#123; char ch; int read=0; int sign=1; do ch=getchar(); while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-'); if(ch=='-') sign=-1,ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; read=read*10+ch-'0'; ch=getchar(); &#125; return read*sign;&#125;int Power2(int x) //把x转化为2的整数次幂&#123; int x0; for(x0=1;x0&lt;=x;x0&lt;&lt;=1) ; return x0;&#125;inline int lg(int n) //计算二进制位数&#123; int l=0; if(n==0) return l; for(int x=1;x&lt;=n;x&lt;&lt;=1) l++; return l;&#125;inline int rev(int x,int n) //位逆序置换&#123; int x0=0; while(n--) x0=(x0+(x&amp;1))&lt;&lt;1,x&gt;&gt;=1; return x0&gt;&gt;1;&#125;void FFT(complex&lt;double&gt; a[],int n,int flag) //主体&#123; complex&lt;double&gt; A[n+1]; for(int i=0,l=lg(n-1);i&lt;n;++i) A[rev(i,l)]=a[i]; #ifdef DEBUG int l=lg(n-1); //切记是lg(n-1) cerr&lt;&lt;"l="&lt;&lt;l&lt;&lt;endl; for(int i=0;i&lt;n;++i) cerr&lt;&lt;rev(i,l)&lt;&lt;" "; cerr&lt;&lt;endl; #endif for(int i=2;i&lt;=n;i&lt;&lt;=1) //枚举合并后序列长度 &#123; complex&lt;double&gt; dw(cos(2*pi/i),sin(flag*2*pi/i)); for(int j=0;j&lt;n;j+=i) //该长度下每部分进行求解 &#123; complex&lt;double&gt; w(1.0,0); for(int k=0;k&lt;(i&gt;&gt;1);k++,w=w*dw) //蝴蝶变换,只需求i&gt;&gt;1次即可 &#123; complex&lt;double&gt; u=A[j+k]; complex&lt;double&gt; t=w*A[j+k+(i&gt;&gt;1)]; A[j+k]=u+t; A[j+k+(i&gt;&gt;1)]=u-t; &#125; &#125; if(flag==-1) for(int i=0;i&lt;n;++i) a[i]=int(A[i].real()/n+0.5); else for(int i=0;i&lt;n;++i) a[i]=A[i]; &#125;&#125;int main()&#123; #ifdef DEBUG freopen("in.txt","r",stdin); #endif n=read(); m=read(); for(int i=0;i&lt;=n;++i) a[i]=read(); for(int i=0;i&lt;=m;++i) b[i]=read(); int length=Power2(n+m); #ifdef DEBUG cerr&lt;&lt;"length="&lt;&lt;length&lt;&lt;endl; #endif FFT(a,length,1); FFT(b,length,1); for(int i=0;i&lt;=length;++i) a[i]*=b[i]; FFT(a,length,-1); for(int i=0;i&lt;=n+m;++i) printf("%d ",int(a[i].real())); return 0;&#125; FFT高精度代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*FFT高精度*/include&lt;bits/stdc++.h&gt;#define PI acos(-1.0)#define eps 1e-1#define maxn 200005#define DEBUGusing namespace std;int n,m,l=0;int rev[maxn],ans[maxn];char x[maxn],y[maxn];struct Complex&#123; double real,imag; Complex(double real=0,double imag=0):real(real),imag(imag) &#123;&#125; Complex operator + (const Complex rhs) &#123; return Complex(real+rhs.real,imag+rhs.imag); &#125; Complex operator - (const Complex rhs) &#123; return Complex(real-rhs.real,imag-rhs.imag); &#125; Complex operator * (const Complex rhs) &#123; return Complex((real*rhs.real-imag*rhs.imag),(real*rhs.imag+imag*rhs.real)); &#125;&#125;;Complex a[maxn],b[maxn];inline int read()&#123; char ch; int read=0,sign=1; do ch=getchar(); while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-'); if(ch=='-') sign=-1,ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; read=read*10+ch-'0'; ch=getchar(); &#125; return sign*read;&#125;void pre_work()&#123; int length1,length2; scanf("%s",x);length1=strlen(x); scanf("%s",y);length2=strlen(y); n=max(length1,length2); for(int i=0;i&lt;length1;++i) a[i].real=x[length1-i-1]-'0'; for(int i=0;i&lt;length2;++i) b[i].real=y[length2-i-1]-'0';#ifdef DEBUG for(int i=0;i&lt;n;++i) cerr&lt;&lt;a[i].real&lt;&lt;" "; cerr&lt;&lt;endl; for(int i=0;i&lt;n;++i) cout&lt;&lt;b[i].real&lt;&lt;" "; cerr&lt;&lt;endl;#endif m=2*n; for(n=1;n&lt;m;n&lt;&lt;=1) l++; for(int i=0;i&lt;n;++i) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;(l-1);#ifdef DEBUG for(int i=0;i&lt;n;++i) cerr&lt;&lt;i&lt;&lt;"--&gt;"&lt;&lt;rev[i]&lt;&lt;endl;#endif&#125;void FFT(Complex a[],int n,int sign)&#123; for(int i=0;i&lt;n;++i) if(rev[i]&lt;i) swap(a[i],a[rev[i]]); for(int i=2;i&lt;=n;i&lt;&lt;=1) &#123; Complex dw(cos(2*PI/i),sin(2*PI*sign/i)); for(int j=0;j&lt;n;j+=i) &#123; Complex w(1,0); for(int k=0;k&lt;(i&gt;&gt;1);k++,w=dw*w) &#123; Complex u=a[j+k]; Complex t=a[j+k+(i&gt;&gt;1)]*w; a[j+k]=u+t; a[j+k+(i&gt;&gt;1)]=u-t; &#125; &#125; &#125; if(sign==-1) for(int i=0;i&lt;n;++i) ans[i]=int(a[i].real/n+eps);&#125;void push_ans()&#123; for(int i=0;i&lt;n;++i) if(ans[i]&gt;=10) ans[i+1]+=ans[i]/10,ans[i]%=10; int first=n-1; while(ans[first]==0) first--; for(int i=first;i&gt;-1;i--) printf("%d",ans[i]);&#125;int main()&#123; pre_work(); FFT(a,n,1); FFT(b,n,1); for(int i=0;i&lt;n;++i) a[i]=a[i]*b[i]; FFT(a,n,-1);#ifdef DEBUG for(int i=0;i&lt;n;++i) cerr&lt;&lt;ans[i]&lt;&lt;" "; cerr&lt;&lt;endl;#endif push_ans(); return 0;&#125; 参考资料 http://blog.csdn.net/oiljt12138/article/details/54810204http://blog.csdn.net/iamzky/article/details/22712347算法导论第三十章]]></content>
      <tags>
        <tag>Math</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流--Dinic算法]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%BD%91%E7%BB%9C%E6%B5%81-Dinic%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Dinic算法例题:CodeVS 1993 草地排水 题目描述 Description在农夫约翰的农场上，每逢下雨，Bessie最喜欢的三叶草地就积聚了一潭水。这意味着草地被水淹没了，并且小草要继续生长还要花相当长一段时间。因此，农夫约翰修建了一套排水系统来使贝茜的草地免除被大水淹没的烦恼（不用担心，雨水会流向附近的一条小溪）。作为一名一流的技师，农夫约翰已经在每条排水沟的一端安上了控制器，这样他可以控制流入排水沟的水流量。 农夫约翰知道每一条排水沟每分钟可以流过的水量，和排水系统的准确布局（起点为水潭而终点为小溪的一张网）。需要注意的是，有些时候从一处到另一处不只有一条排水沟。 根据这些信息，计算从水潭排水到小溪的最大流量。对于给出的每条排水沟，雨水只能沿着一个方向流动，注意可能会出现雨水环形流动的情形。输入描述 Input Description第1行: 两个用空格分开的整数N (0 &lt;= N &lt;= 200) 和 M (2 &lt;= M &lt;= 200)。N是农夫John已经挖好的排水沟的数量，M是排水沟交叉点的数量。交点1是水潭，交点M是小溪。 第二行到第N+1行: 每行有三个整数，Si, Ei, 和 Ci。Si 和 Ei (1 &lt;= Si, Ei &lt;= M) 指明排水沟两端的交点，雨水从Si 流向Ei。Ci (0 &lt;= Ci &lt;= 10,000,000)是这条排水沟的最大容量。 输出描述 Output Description输出一个整数，即排水的最大流量。 样例输入 Sample Input5 41 2 401 4 202 4 202 3 303 4 10 样例输出 Sample Output50 问题分析很显然，这是一道网络流问题，源点为1号节点，汇点为第n号节点，中间的点之间由有向边连接，边权即为流量wi，这样就简单构造了一个网络流的问题，由于题目要求排水的最大流量，也就是求出此网络中的最大流。 对于求最大流的问题，大家入门时一定接触的是EK算法，但是EK算法的效率实在感人，难以满足竞赛中的需要，而Dinic算法通过对EK算法简单的优化使其效率有了明显的提升，基本能够满足竞赛对求最大流的效率的要求。那么Dinic是怎样优化的呢？ Dinic算法有三个关键词：增广路，残量网络，层次。 首先，增广路就是每次从源点扩展一条可以到汇点的路径，然后更新一遍残留网络后继续寻找一条这样的路径的过程直至从源点到汇点没有一条路径可达时停止，这个过程就是求增广路的过程。（附上一组求增广路的流程图） 残量网络是Dinic算法（也是EK算法）的关键，残量网络实际上就是流网络上一条边在当前流量的基础上可以允许的额外流量，即 $C_f(u,v)=c(u,v) -f(u,v)$ 但需要特别注意的是，当 $C_f(u,v)$ 为0时该条边将不属于图 $ G_f $。残量网络的构建相当于给了你一个后悔的机会，将原来已经删去的路在可以得到更优解时换回来，即将反向弧再次反向，又回到原来的状态。 之前两点并不是Dinic算法独有的，EK算法同样需要，然而Dinic更优秀的地方就在于第三点，它求增广路前先将图进行分层，逐层递进寻找增广路，这样每条路都是s-t最短路，根据最短增广路算法中的证明（不必深究），可以确定这样找增广路的效率得到大幅提高！ 代码了解了算法的关键，码出来也不会有太大障碍，每次增光前bfs分一次层即可，下面附上代码(邻接矩阵存储)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define maxn 255using namespace std;const int INF=0x3f3f3f3f;int n,m;int edge[maxn][maxn];int now[maxn],dis[maxn];int bfs() //分层&#123; memset(dis,-1,sizeof(dis)); queue&lt;int &gt; q; q.push(1); dis[1]=0; while(!q.empty()) &#123; int u=q.front() ; q.pop(); for(int i=1;i&lt;=n;++i) &#123; if(dis[i]==-1 &amp;&amp; edge[u][i]&gt;0) &#123; dis[i]=dis[u]+1; q.push(i); &#125; &#125; &#125; return dis[n]==-1?0:dis[n];&#125;int MaxFlow(int u,int flow)&#123; if(u==n) return flow; int post_maxflow; for(int i=now[u];i&lt;n;++i) //当前弧优化 &#123; now[u]=1; if(dis[i+1]==dis[u]+1 &amp;&amp; edge[u][i+1]&gt;0 &amp;&amp; (post_maxflow=MaxFlow(i+1,min(flow,edge[u][i+1])))) &#123; edge[u][i+1]-=post_maxflow; edge[i+1][u]+=post_maxflow; return post_maxflow; &#125; &#125; return 0;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int sumflow=0; memset(edge,0,sizeof(edge)); scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=m;++i) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[u][v]+=w; &#125; while(bfs()) &#123; int flow; memset(now,0,sizeof(now)); while(flow=MaxFlow(1,INF)) sumflow+=flow; &#125; printf("%d",sumflow); return 0;&#125; 但是当图很大时，邻接矩阵显然无法满足我们的需求，如POJ3469 Dual Core CPU 中 n&lt;=20000,这时再用邻接矩阵会ML，只要将图该用邻接表存储即可，附上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define Repeat(s,t) for(int i=(s);i&lt;(t);++i)#define INF 0x3f3f3f3f#define maxn 20000+50#define DEBUGusing namespace std;struct edge&#123; int from,to,cap,flow; edge(int from,int to,int cap,int flow):from(from),to(to),cap(cap),flow(flow) &#123;&#125;&#125;;struct dinic&#123; int n,m,s,t; vector&lt;edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn]; int cur[maxn]; dinic() &#123;&#125; void init() &#123; memset(d,-1,sizeof(d)); memset(cur,0,sizeof(0)); &#125; void add_edge(int from,int to,int cap,int flag) &#123; if(!flag) &#123; edges.push_back(edge(from,to,cap,0)); edges.push_back(edge(to,from,0,0)); &#125; else &#123; edges.push_back(edge(from,to,cap,0)); edges.push_back(edge(to,from,cap,0)); &#125; m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool bfs() &#123; memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s]=0; while(!q.empty()) &#123; int u=q.front() ; q.pop(); for(unsigned int i=0;i&lt;G[u].size();++i) &#123; edge&amp; e=edges[G[u][i]]; if(d[e.to]==-1 &amp;&amp; e.cap&gt;e.flow) &#123; d[e.to]=d[u]+1; q.push(e.to); &#125; &#125; &#125; return d[t]==-1?0:1; &#125; int dfs(int x,int a) &#123; if(x==t || a==0) return a; int flow=0,f; for(unsigned int i=cur[x];i&lt;G[x].size();++i) &#123; cur[x]=i; edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to] &amp;&amp; (f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0) &#123; e.flow+=f; edges[G[x][i]^1].flow-=f; flow+=f; a-=f; if(a==0) break; &#125; &#125; return flow; &#125; int MaxFlow(int n,int s,int t) &#123; this-&gt;n=n; this-&gt;s=s; this-&gt;t=t; int flow=0; while(bfs()) &#123; memset(cur,0,sizeof(cur)); flow+=dfs(s,INF); &#125; return flow; &#125;&#125;;inline int read()&#123; /*神tm一定要注意过滤掉数据前面的多余空格或者换行符!否则会导致不可名状的错误!po主付出过惨痛代价QAQ*/ char ch; do ch=getchar(); while((ch &lt; '0' || ch &gt; '9') &amp;&amp; ch !='-'); int read=0; bool sign=0; if(ch=='-') &#123; sign=1; ch=getchar(); &#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9') &#123; read=read*10+ch-'0'; ch=getchar(); &#125; return sign==0?read:-read;&#125;inline void write(int out)&#123; if(out&lt;0) &#123; putchar('-'); out=-out; &#125; if(out&gt;9) write(out/10); putchar(out%10+'0');&#125;int main()&#123; int n,m; n=read(); m=read(); int s=0,t=n+1; dinic D; Repeat(1,n+1) &#123; int a=read(),b=read(); D.add_edge(s,i,a,0); D.add_edge(i,t,b,0); &#125; Repeat(1,m+1) &#123; int a=read(),b=read(),w=read(); D.add_edge(a,b,w,1); &#125; write(D.MaxFlow(n,s,t)); return 0;&#125;]]></content>
      <tags>
        <tag>Math</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶梯博弈]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%98%B6%E6%A2%AF%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[阶梯博弈阐述阶梯博弈也是博弈论中重要的一个分支，所谓阶梯博弈，其实指代的是一类只能从后向前逐层传递石子的游戏的模型，同样的，这类问题也可以转化成NIM取石子问题求解 题型前五堆石子分别有2,1,3,1,4个石子，每个人只能把后面的任意多个石子向前移，不能移动者为负，现在问先手必胜还是必败？ 分析这个很简单，分别把五堆石子编号0~4，很显然当把所有石子移到0堆的一方获胜，即对应先手必胜态。不考虑编号后的奇数堆（可以假设奇数堆上没有石子可以移动），对于所有偶数堆，率先移动的一方肯定会失败，这是显然的，因为目标堆是第0堆，而移动2k堆只能到2k-1堆，即奇数堆，另一方再次移动又会回到偶数堆的情况，如此往复，最终一定是面对均为偶数堆的一方失败，这样看来，偶数堆对胜负的影响可以转化为哪一方先将所有奇数堆移动完即可取得胜利。有了这样的转化，问题就迎刃而解了，因为每次可以移动任意多个，所以从奇数堆移到偶数堆就可以等效成取走奇数堆中的石子，这个问题很熟悉，不就是NIM取石子问题么！只要对奇数堆的石子做NIM取石子问题便可求解原问题。如果对手不对奇数堆移动，而选择移动偶数（2k）堆到第2k-1堆，方法同样很简单，你只需要以其人之道还治其人之身，把他移动的相等数量的石子再从2k-1堆移动到2k-2堆，这样等效于又回到了原来的局面。 P3480 [POI2009]KAM-Pebbles题目描述： 有N堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。 解决方案：对于任意一个堆进行符合要求的取石子操作后，易知：**它与后一个堆的石子差增加，而与前一个堆的石子差减小（一定注意前后的增减情况，这会影响阶梯博弈的方向！）**，而增减的幅度相同，这就等效于把前面的石子向相邻右侧移动了一位，即可以转化为将原数组的差分数组进行一次阶梯博弈，原问题即可求解！ 代码：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1010;int cnt;int a[maxn],M[maxn];int main()&#123; scanf("%d",&amp;cnt); while(cnt--) &#123; int n,xorsum; scanf("%d",&amp;n); a[0]=0; xorsum=0; for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;++i) M[i]=a[n-i+1]-a[n-i]; for(int i=1;i&lt;=n;i+=2) xorsum^=M[i]; if(xorsum) printf("TAK\n"); else printf("NIE\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Math</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Colaboratory的使用]]></title>
    <url>%2F2019%2F04%2F08%2FColaboratory%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Google备份与同步在使用Colaboratory之前，由于涉及GoogleDrive的文档同步，需要在电脑上安装Google备份与同步软件 GoogleDrive安装https://www.google.com/intl/zh-CN_ALL/drive/download/backup-and-sync/ 登陆问题处理在安装完软件之后需要登陆Google账户，但是一直在提示“无法正常登陆，请检查网络连接”在确认VPN可以正常使用后百度到了处理这类问题的正确姿势解决Mac下Google备份和同步网络连接问题 系统编号设置-&gt;网络-&gt;高级…-&gt;代理-&gt;网页代理(HTTP)-&gt;设置代理（127.0.0.1:1087） 登陆成功！ 设置GPU加速 修改-&gt;笔记本设置-&gt;硬件加速器-&gt;GPU 检查GPU是否启用 12import tensorflow as tftf.test.gpu_device_name() 显示GPU详细信息 12from tensorflow.python.client import device_libdevice_lib.list_local_devices() 显示CPU详细信息 1!cat /proc/cpuinfo 使用Colab打开.py文件转载说明该部分转载自[薅资本主义羊毛，用Google免费GPU][2] 配置服务器 123456789101112!apt-get install -y -qq software-properties-common python-software-properties module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; 按步骤要求点击链接输入验证码即可 授权完成后挂载GoogleDrive： 12!mkdir -p drive!google-drive-ocamlfuse drive GoogleDrive文档打开位置 1cd /drive/xxx 重置(reset)服务器1!kill -9 -1]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[venv的安装和使用]]></title>
    <url>%2F2019%2F04%2F08%2Fvenv%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装venv1python3 install virtualenv venv的使用 在当前目录创建虚拟环境 1python3 -m venv . 在当前目录创建独立的python环境 1virtualenv --no-site-packages venv 激活虚拟环境 1source venv/bin/activate 停用虚拟环境 1deactivate 删除虚拟环境 1rm -rf venv 参考网站https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000 https://www.cnblogs.com/LittleMore/p/6693154.html https://www.cnblogs.com/technologylife/p/6635631.html]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速线性筛法求素数]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%BF%AB%E9%80%9F%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[筛法求素数基本步骤说到求素数，其实在刚开始学C++的时候就已经见过诸如此类的问题，不过现在最常见的还是筛法求素数 谈及筛法求素数，其大致思路可分为如下五步： 把2到n的自然数放入a[2]到a[n]中(所放入的数与下标号相同) ; 在数组元素中以下标为序，按顺序找到未曾找过的最小素数minp和它的位置p(即下标号); 从p+1开始，把凡是能被minp整除的各元素值从a数组中划去(筛掉)，也就是把该元素标记为0; 让p=p+1，重复执行第(2) (3)步骤，知道，minp&gt;floor(sqrt(n))为止; 打印输出a数组中留下来的数，未被筛掉的各元素值; 缺陷分析这种求素数的算法很容易被理解，其时间复杂度介于O(n)~O(n*logn)是一种比较流行的方法。但是同样的，这种算法也存在先天性的缺陷，我们简单分析： 对于一个数30，可分解为30=215=310=5*6，显然，当循环,2,3,5,6,10,15时都会筛除一次30这个数，而当n很大时，就会出现许多的冗余操作，这个算法可以进一步进行优化来使算法的效率提高，因此，一种名为快速线性筛法的算法应运而生。这种算法的智慧之处在于——对于2~n的每一个数，它只筛去到目前为止它能筛到而之后的其他数筛不到的几个合数，而把它能筛到，另有别的数也能筛到的数留个接下来的数去筛，这样的话就能使得素数的筛选不重不漏——说起来容易做起来难，这样的算法应该如何实现呢？ 快速线性筛法求素数基本步骤对于快速筛法求素数，其步骤也可分为如下几个阶段： 开一个n+1大小的数组num[n]来存放每一个元素的筛留情况(即对于num[n]的每个数与下标号相同，对于任意num[n]有num[n]=0,num[n]=1两种情况，如果num[n]=0则是素数，反之num[n]=1时是合数); 再开一个数组prime[n]来存放筛出的素数以便最后输出结果; 对于一个数k,总是进行从n*prime[0]~n*prime[j](由小到大来乘)，直到if(n%prime[j]==0)成立时break掉 这是这个算法的精髓所在，所以弄清楚原因是十分必要的！！！对于一个数c=a*b(b为c的最小质因数），当通过该算法的循环循环至c*b时，易得此时c%b==0,如果此时继续循环至b后面的一个素数d，则有：c*d=a*b*d=(a*d)*b，因为d&gt;b,所以a*d&gt;c。当循环从c继续查找到a*d时我们发现当a*d再次与素数b想乘时，就又对cd进行了一次操作，出现了冗余，所以在if(n%prime[j]==0)成立时要将该层循环break掉；举个例子，对于一个数9，9\2=18将18标记为合数，循环继续；9\3=27将27标记为合数，此时发现9%3=0，循环退出。如果将循环继续下去会出现筛除9\5=45的情况，而45=15*3，在15时会被在筛去一次，故不可行 完成了算法中最重要的一步，最后只要将存放筛出的prime[]数组中的素数即可！ 这种算法的写法也十分简单，这里只给出一种与普通筛法求素数比较程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#define inf 20000005using namespace std;int n;bool a[inf+1];long num[inf+1]=&#123;1,1&#125;,prime[inf+1]=&#123;0&#125;,number=0; void putongshaifa() &#123; clock_t begin,end; begin=clock(); for(int i=0;i&lt;=n;++i) a[i]=true; a[1]=false; for(int i=2;i&lt;sqrt(n);++i) if(a[i]) for(int j=2;j&lt;=n/i;++j) a[i*j]=false; end=clock(); /*for(int i=2,t=0;i&lt;=n;++i) if(a[i]) &#123; cout&lt;&lt;i&lt;&lt;" "; ++t; if(t%10==0) cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;*/ printf("普通筛法-Time used:%d ms\n",end-begin); return;&#125;void kuaisushaifa() &#123; clock_t begin,end; begin=clock(); for(int i=2;i&lt;=n;++i) &#123; if(!num[i]) prime[number++]=i; for(int j=0;j&lt;number &amp;&amp; i*prime[j]&lt;=n;j++) &#123; num[i*prime[j]]=1; if(!(i%prime[j])) break; &#125; &#125; end=clock(); /*for(int i=0;i&lt;number;i++) &#123; if(i%10==0) printf("\n"); printf("%3d",prime[i]); &#125; */ printf("快速筛法-Time used:%d ms\n",end-begin); return;&#125;int main()&#123; //freopen("prime.txt","w",stdout); scanf("%d",&amp;n); int _test=10; while(_test--) &#123; putongshaifa(); kuaisushaifa(); cout&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式的推导与应用]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题简介错排问题，又称更列问题，是组合数学中的问题之一。对于它的研究最早可以追溯到十八世纪，当时他被数学家尼古拉·伯努利和欧拉研究，因此在历史上也被称为伯努利—欧拉的错装信封问题。这个问题有许多具体的版本，比如在写信时讲n封信装到n个不同的信封里，有多少种全部装错信封的情况？再比如n个人各写一张贺卡相互赠送，有多少种赠送方法？这些经典的题目都是典型的错排问题。 问题分析相信看过上面对于错排问题的简单的介绍，大家也都对它有了一些初步的了解，归结起来，就是考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排，n个元素的错排数记为D(n)。那么对于这样的排列D(n)有多少种呢？ 我们一步一步进行分析：首先，对于D(n)，有1~n这样n个元素错排，所以对于第一个元素①，它现在可能的位置有(n-1)个，倘若它在第k个元素的位置上，对于第k个元素而言，它所在的位置就有两种可能—第一种，它处在非第一个元素①位置上，所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1);第二种，它处在第一个元素①的位置上，所以在排列D(n)中有两个元素找到了位置，那么接下来的队列就相当于是n-2个元素的错排。因此，对于D(n)都有 D_n=(n-1)*(D_{n-1}+D_{n-2}) (n>2)得到这个递推式之后，我们进一步进行推导： 为了运算的方便，我们设 $D_n=n!*N_n$, 则有: $n!N_n=(n-1)(n-2)!N_{n-2}+(n-1)(n-1)!*N_{n-1}$ 两边同时除以(n-1)! ,可得： n*N_n=N_{n-2}+(n-1)*N_{n-1}移项： N_n-N_{n-1}=(N_{n-2}-N_{n-1})/n = -(1/n)(N_{n-1}-N_{n-2})错项相消得： N_n-N_1=1/2!-1/3!+1/4!- ··· ··· +(-1)^{n-1}/(n-1)!+(-1)^n/n!由于N(1)=0，N(2)=1, 所以 $N_n=1/2!-1/3!+1/4!- ··· ··· +(-1)^{n-1}/(n-1)!+(-1)^n/n!$ 于是可以得到错排公式为: D_n=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +(-1)^{n-1}/(n-1)!+(-1)^n/n!)这样，我们就通过简单的推导得到了两个关于错排问题的公式！ 例题分析现在，我们来具体问题具体分析，了解错排公式如何转化为代码来解决考试中实际遇到的问题，我们这里以HDU Online Judge上的一道题考新郎为例，题目是这样的： 阅读题目后我们不难发现，这道题的本质就是求解排列组合C(n,m)与错排m个元素D(m)的乘积，因此这道题的代码也十分简单，以下提供两种AC程序：方法1-递推公式: D_n=(n-1)*(D_{n-1}+D_{n-2}) (D_1=0，D_2=1)12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;long long _cuopai[50];long long jiecheng[22]=&#123;1,1,2,6,24,120,720,5040,40320, 362880,3628800,39916800,479001600, 6227020800,87178291200,1307674368000, 20922789888000,355687428096000,6402373705728000, 121645100408832000,2432902008176640000&#125;;long long cuopai(int x)&#123; if(_cuopai[x]) return _cuopai[x]; if(x==1) return 0; if(x==2) return 1; return _cuopai[x]=(x-1)*(cuopai(x-1)+cuopai(x-2));&#125; long long c(int y,int z)&#123; return jiecheng[y]/(jiecheng[z]*jiecheng[y-z]);&#125; int main()&#123; memset(_cuopai,0,sizeof(_cuopai)); int a; cin&gt;&gt;a; for(int i=1;i&lt;=a;++i) &#123; int m,n; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;c(m,n)*cuopai(n)&lt;&lt;endl; &#125; return 0;&#125; 方法2-通项公式: D_n=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +(-1)^{n-1}/(n-1)!+(-1)^n/n!)这里可以根据题目做一下变形: F(n,m)=C(n,m)*D(m)=n!*(1/2!-1/3!+1/4!- 1/5!+ ··· ··· +(-1)^{m-1}/(m-1)!+(-1)^m/m!)/(n-m)!123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int m,n;long long jiecheng[22]=&#123;1,1,2,6,24,120,720,5040,40320, 362880,3628800,39916800,479001600, 6227020800,87178291200,1307674368000, 20922789888000,355687428096000,6402373705728000, 121645100408832000,2432902008176640000&#125;; long long cuopai_()&#123; long long sum=0,a=jiecheng[n],b=jiecheng[n-m]; for(int i=2;i&lt;=m;++i) &#123; a/=i; if(i%2==0) sum+=a; else sum-=a; //cout&lt;&lt;"sum["&lt;&lt;i&lt;&lt;"]"&lt;&lt;sum&lt;&lt;endl; &#125; return sum/b;&#125; int main()&#123; int x; cin&gt;&gt;x; for(int i=1;i&lt;=x;++i) &#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;cuopai_()&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WelcomePage]]></title>
    <url>%2F2019%2F04%2F08%2FWelcomePage%2F</url>
    <content type="text"><![CDATA[Welcome to my new blog Hope you can leave messages here ! Details manager:yangyuhao set_time:2019-04-07 update_time:2019-04-08 Contract QQ: 895258058 E-mail: yangyh408@qq.com GitHub: yangyh408]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>
